# -*- coding: utf-8 -*-
"""Algoritmo_A1_C1_V1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gG1sble079GGcBmxPScxkr6oo19hATpN
"""

# @title Montar acceso Google Drive
# ==============================================================================
# 1. Montar Google Drive en Colab (si los archivos están allí)
# ==============================================================================

from google.colab import drive
drive.mount('/content/drive')
print("Google Drive montado con éxito.")

# @title Rutas de las BD
ruta_labs = "/content/drive/Shareddrives/111598 | Entregables Delfos 3/INNprende/2 - Desarrollo de Modelos de ML y DL pa- ra Biomarcadores Digitales/2.2 Prototipo Funcional de Modelos Iniciales/Glucosa_Unique.csv"

# @title
import pandas as pd

# --- Configuración para mostrar todas las filas y columnas ---
# Establece la opción para no truncar la visualización de filas
pd.set_option('display.max_rows', None)
# Establece la opción para no truncar la visualización de columnas
pd.set_option('display.max_columns', None)


# --- Carga y muestra de tus datos ---
# Reemplaza esta ruta con la ubicación de tu archivo si es diferente
ruta_labs = "/content/drive/Shareddrives/111598 | Entregables Delfos 3/INNprende/2 - Desarrollo de Modelos de ML y DL pa- ra Biomarcadores Digitales/2.2 Prototipo Funcional de Modelos Iniciales/Glucosa_Unique.csv"

# Leer el archivo CSV en un DataFrame de pandas
# Es una buena práctica usar un bloque try-except para manejar errores si el archivo no se encuentra
try:
    df = pd.read_csv(ruta_labs)
    # Imprimir el DataFrame completo
    print(df)
except FileNotFoundError:
    print(f"Error: No se encontró el archivo en la ruta especificada: {ruta_labs}")
except Exception as e:
    print(f"Ocurrió un error al leer el archivo: {e}")

"""# Base de Datos"""

# @title
from google.colab import data_table

data_table.enable_dataframe_formatter()

df

# @title
import pandas as pd

# Cargar el archivo
ruta = "/content/drive/Shareddrives/111598 | Entregables Delfos 3/INNprende/2 - Desarrollo de Modelos de ML y DL pa- ra Biomarcadores Digitales/2.2 Prototipo Funcional de Modelos Iniciales/Glucosa_Unique.csv"
df = pd.read_csv(ruta)

# Crear la nueva columna según los rangos clínicos
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif 100 < valor <= 125:
        return "Prediabetes"
    elif valor >= 126:
        return "Diabetes"
    else:
        return "Desconocido"  # por si hay valores nulos o fuera de rango

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# Ver las primeras filas para confirmar
print(df[["Resultado", "Categoria_Glucosa"]].head(99))

# @title
import pandas as pd
import numpy as np

# Cargar CSV original
ruta_entrada = "/content/drive/Shareddrives/111598 | Entregables Delfos 3/INNprende/2 - Desarrollo de Modelos de ML y DL pa- ra Biomarcadores Digitales/2.2 Prototipo Funcional de Modelos Iniciales/Glucosa_Unique.csv"
df = pd.read_csv(ruta_entrada)

# Asegurarnos que 'Resultado' sea numérico (NaN si no se puede convertir)
df['Resultado'] = pd.to_numeric(df['Resultado'], errors='coerce')

# Tu función (exactamente como la propusiste)
def clasificar_glucosa(valor):
    if pd.isna(valor):
        return "Desconocido"
    if valor <= 100:
        return "Normal"
    elif 100 < valor <= 125:
        return "Prediabetes"
    elif valor >= 126:
        return "Diabetes"
    else:
        return "Desconocido"

# Crear la columna sin eliminar nada del DataFrame original
df['Categoria_Glucosa'] = df['Resultado'].apply(clasificar_glucosa)

# Guardar un nuevo CSV que contiene todas las columnas originales + Categoria_Glucosa
ruta_salida = "/content/drive/MyDrive/Glucosa_Unique_Completo.csv"
df.to_csv(ruta_salida, index=False)

# Mostrar resumen rápido
print("✅ Guardado en:", ruta_salida)
print("\nConteo por categoría:")
print(df['Categoria_Glucosa'].value_counts(dropna=False))
print(f"\nMínimo Resultado: {df['Resultado'].min()}    Máximo Resultado: {df['Resultado'].max()}")
print("\nPrimeras filas:")
print(df.head())

"""# Modelo entrenado ML Random Forest




"""

# @title Entrenar Random Forest con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion","Nombre_Completo","identificacion",
    "nombres","apellidos"
]
target = "Resultado"

df_limpio = df.dropna(subset=[target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64","float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64","float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Random Forest ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", RandomForestRegressor(n_estimators=300, random_state=42))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Crear predicciones categóricas ---
def clasificar_prediccion(valor_pred):
    if valor_pred <= 100:
        return "Normal"
    elif valor_pred <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

y_pred_train_cat = [clasificar_prediccion(v) for v in y_pred_train]
y_pred_test_cat = [clasificar_prediccion(v) for v in y_pred_test]

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modeloentrenadoramdonforest.joblib"
joblib.dump(model, ruta_guardado)
print(f"Modelo guardado en: {ruta_guardado}")

"""# Modelo entrenado ML Random Forest_1

"""

# @title Cargar modelo Random Forest ya entrenado, evaluar y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- Cargar dataset y modelo ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modeloentrenadoramdonforest.joblib"

df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- Selección de características ---
features_seleccionadas = [
    "Categoria_Glucosa", "Resultado",
    "Identificacion","Nombre_Completo","identificacion","nombres","apellidos"
]
target = 'Resultado'

df_limpio = df.dropna(subset=[target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- División 70/30 para evaluar como en entrenamiento ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN CON MODELO CARGADO")
print("="*50)
print(f"[ENTRENAMIENTO] R² = {r2_train:.3f} | RMSE = {rmse_train:.2f} mg/dL | MAE = {mae_train:.2f} mg/dL | n={len(y_train)}")
print(f"[PRUEBA       ] R² = {r2_test:.3f} | RMSE = {rmse_test:.2f} mg/dL | MAE = {mae_test:.2f} mg/dL | n={len(y_test)}")
print("="*50)

# --- Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val, max_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min()), max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y=x)")
plt.title(f"Modelo Random Forest (Cargado)\nR² prueba = {r2_test:.3f} | RMSE prueba = {rmse_test:.2f} mg/dL | MAE prueba = {mae_test:.2f} mg/dL")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo entrenado ML Random Forest_2

"""

# @title Entrenar y guardar modelo Random Forest solo con las columnas seleccionadas
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
import joblib

# --- Carga de Datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- Selección de características ---
features_seleccionadas = [
    'Identificacion', 'identificacion', 'Nombre_Completo', 'nombres',
    'apellidos', 'Fecha_Examen', 'Fecha_Fin_Registro', 'fecha_nacimiento',
    'responsable_registro', 'servicio', 'Examen', 'Analito'
]
target = 'Resultado'

df_limpio = df.dropna(subset=[target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- Preprocesamiento ---
numeric_cols = X.select_dtypes(include=np.number).columns.tolist()
categorical_cols = X.select_dtypes(exclude=np.number).columns.tolist()

numeric_transformer = Pipeline(steps=[('imputer', SimpleImputer(strategy='median'))])
categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])
preprocess = ColumnTransformer(transformers=[
    ('num', numeric_transformer, numeric_cols),
    ('cat', categorical_transformer, categorical_cols)
])

# --- Modelo ---
rf_model = RandomForestRegressor(n_estimators=300, random_state=42, n_jobs=-1)
model = Pipeline(steps=[('preprocess', preprocess), ('regressor', rf_model)])

# --- Entrenamiento ---
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)
model.fit(X_train, y_train)

# --- Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RANDOM FOREST")
print("="*50)
print(f"[ENTRENAMIENTO] R² = {r2_train:.3f} | RMSE = {rmse_train:.2f} mg/dL | MAE = {mae_train:.2f} mg/dL | n={len(y_train)}")
print(f"[PRUEBA       ] R² = {r2_test:.3f} | RMSE = {rmse_test:.2f} mg/dL | MAE = {mae_test:.2f} mg/dL | n={len(y_test)}")
print("="*50)

# --- Guardar modelo entrenado ---
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_rf_seleccionado.joblib"
joblib.dump(model, ruta_modelo)
print(f"✅ Modelo guardado en: {ruta_modelo}")

# @title Cargar modelo Random Forest ya entrenado y graficar con MAE
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- Cargar dataset y modelo ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_rf_seleccionado.joblib"

df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- Selección de características ---
features_seleccionadas = [
    'Identificacion', 'identificacion', 'Nombre_Completo', 'nombres',
    'apellidos', 'Fecha_Examen', 'Fecha_Fin_Registro', 'fecha_nacimiento',
    'responsable_registro', 'servicio', 'Examen', 'Analito'
]
target = 'Resultado'

df_limpio = df.dropna(subset=[target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- División 70/30 para evaluar como en entrenamiento ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN CON MODELO CARGADO")
print("="*50)
print(f"[ENTRENAMIENTO] R² = {r2_train:.3f} | RMSE = {rmse_train:.2f} mg/dL | MAE = {mae_train:.2f} mg/dL | n={len(y_train)}")
print(f"[PRUEBA       ] R² = {r2_test:.3f} | RMSE = {rmse_test:.2f} mg/dL | MAE = {mae_test:.2f} mg/dL | n={len(y_test)}")
print("="*50)

# --- Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val, max_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min()), max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y=x)")
plt.title(f"Modelo Random Forest (Cargado)\nR² prueba = {r2_test:.3f} | RMSE prueba = {rmse_test:.2f} | MAE prueba = {mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo entrenado ML Random Forest_3"""

# @title Entrenar y guardar modelo Random Forest solo con las columnas seleccionadas
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
import joblib

# --- Carga de Datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- Selección de características ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=[target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- Preprocesamiento ---
numeric_cols = X.select_dtypes(include=np.number).columns.tolist()
categorical_cols = X.select_dtypes(exclude=np.number).columns.tolist()

numeric_transformer = Pipeline(steps=[('imputer', SimpleImputer(strategy='median'))])
categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])
preprocess = ColumnTransformer(transformers=[
    ('num', numeric_transformer, numeric_cols),
    ('cat', categorical_transformer, categorical_cols)
])

# --- Modelo ---
rf_model = RandomForestRegressor(n_estimators=300, random_state=42, n_jobs=-1)
model = Pipeline(steps=[('preprocess', preprocess), ('regressor', rf_model)])

# --- Entrenamiento ---
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)
model.fit(X_train, y_train)

# --- Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RANDOM FOREST")
print("="*50)
print(f"[ENTRENAMIENTO] R² = {r2_train:.3f} | RMSE = {rmse_train:.2f} mg/dL | MAE = {mae_train:.2f} mg/dL | n={len(y_train)}")
print(f"[PRUEBA       ] R² = {r2_test:.3f} | RMSE = {rmse_test:.2f} mg/dL | MAE = {mae_test:.2f} mg/dL | n={len(y_test)}")
print("="*50)

# --- Guardar modelo entrenado ---
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_rf_seleccionado_numero3.joblib"
joblib.dump(model, ruta_modelo)
print(f"✅ Modelo guardado en: {ruta_modelo}")

# @title Cargar modelo Random Forest ya entrenado y graficar con MAE
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- Cargar dataset y modelo ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_rf_seleccionado_numero3.joblib"

df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- Selección de características ---
features_seleccionadas = [
 "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=[target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- División 70/30 para evaluar como en entrenamiento ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN CON MODELO CARGADO")
print("="*50)
print(f"[ENTRENAMIENTO] R² = {r2_train:.3f} | RMSE = {rmse_train:.2f} mg/dL | MAE = {mae_train:.2f} mg/dL | n={len(y_train)}")
print(f"[PRUEBA       ] R² = {r2_test:.3f} | RMSE = {rmse_test:.2f} mg/dL | MAE = {mae_test:.2f} mg/dL | n={len(y_test)}")
print("="*50)

# --- Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val, max_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min()), max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y=x)")
plt.title(f"Modelo Random Forest (Cargado)\nR² prueba = {r2_test:.3f} | RMSE prueba = {rmse_test:.2f} | MAE prueba = {mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Regresión Lineal_1



"""

# @title Entrenar Regresión Lineal con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target (sin días entre examen) ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Regresión Lineal ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", LinearRegression())
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Regresión Lineal)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_regresion_lineal.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo de regresión lineal guardado en: {ruta_guardado}")

# @title Cargar modelo de Regresión Lineal entrenado y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_regresion_lineal.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de características (sin días entre examen) ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

# --- 5. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 8. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO DE REGRESIÓN LINEAL")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 10. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Regresión Lineal\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Regresión Lineal_2

"""

# @title Entrenar Regresión Lineal con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Crear columna de días entre examen y fin ---
df["Fecha_Examen"] = pd.to_datetime(df["Fecha_Examen"], errors="coerce")
df["Fecha_Fin_Registro"] = pd.to_datetime(df["Fecha_Fin_Registro"], errors="coerce")
df["Dias_entre_examen_y_fin"] = (df["Fecha_Fin_Registro"] - df["Fecha_Examen"]).dt.days

# --- 4. Selección de features y target ---
features_seleccionadas = [
    "Edad_Años", "Dias_entre_examen_y_fin", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 5. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 6. Pipeline con Regresión Lineal ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", LinearRegression())
])

# --- 7. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 8. Entrenar ---
model.fit(X_train, y_train)

# --- 9. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Regresión Lineal)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_regresion_lineal_dias.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo de regresión lineal guardado en: {ruta_guardado}")

# @title Cargar modelo de Regresión Lineal entrenado y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_regresion_lineal_dias.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Calcular días entre examen y fin ---
df["Fecha_Examen"] = pd.to_datetime(df["Fecha_Examen"], errors="coerce")
df["Fecha_Fin_Registro"] = pd.to_datetime(df["Fecha_Fin_Registro"], errors="coerce")
df["Dias_entre_examen_y_fin"] = (df["Fecha_Fin_Registro"] - df["Fecha_Examen"]).dt.days

# --- 5. Selección de características ---
features_seleccionadas = [
    "Edad_Años", "Dias_entre_examen_y_fin", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

# --- 6. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 7. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO DE REGRESIÓN LINEAL")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 11. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Regresión Lineal\nR² prueba={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Regresión Lineal_3

"""

# @title Entrenar Regresión Lineal con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target (sin días entre examen) ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion", "Nombre_Completo",
    "identificacion", "nombres", "apellidos"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Regresión Lineal ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", LinearRegression())
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Regresión Lineal)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_regresion_lineal_3.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo de regresión lineal guardado en: {ruta_guardado}")

# @title Cargar modelo de Regresión Lineal entrenado y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_regresion_lineal_3.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de características (sin días entre examen) ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion", "Nombre_Completo",
    "identificacion", "nombres", "apellidos"
]
target = "Resultado"

# --- 5. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 8. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO DE REGRESIÓN LINEAL")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 10. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Regresión Lineal\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Ridge Regression"""

# @title Entrenar Ridge Regression con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import Ridge
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target (sin días entre examen) ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Ridge Regression ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", Ridge(alpha=1.0))  # Puedes ajustar alpha según convenga
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Ridge Regression)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_ridge_regression.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo Ridge Regression guardado en: {ruta_guardado}")

# @title Cargar modelo de Ridge Regression entrenado y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_ridge_regression.joblib"  # Modelo Ridge

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de características (sin días entre examen) ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

# --- 5. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 8. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO DE RIDGE REGRESSION")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 10. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Ridge Regression\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Ridge Regression_2"""

# @title Entrenar Ridge Regression con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import Ridge
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Crear columna de días entre examen y fin ---
df["Fecha_Examen"] = pd.to_datetime(df["Fecha_Examen"], errors="coerce")
df["Fecha_Fin_Registro"] = pd.to_datetime(df["Fecha_Fin_Registro"], errors="coerce")
df["Dias_entre_examen_y_fin"] = (df["Fecha_Fin_Registro"] - df["Fecha_Examen"]).dt.days

# --- 4. Selección de features y target ---
features_seleccionadas = [
    "Edad_Años", "Dias_entre_examen_y_fin", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 5. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 6. Pipeline con Ridge Regression ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", Ridge(alpha=1.0))  # Puedes ajustar alpha si quieres más regularización
])

# --- 7. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 8. Entrenar ---
model.fit(X_train, y_train)

# --- 9. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Ridge Regression)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_ridge_regression.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo Ridge Regression guardado en: {ruta_guardado}")

# @title Cargar modelo Ridge Regression entrenado y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_ridge_regression.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Crear columna de días entre examen y fin ---
df["Fecha_Examen"] = pd.to_datetime(df["Fecha_Examen"], errors="coerce")
df["Fecha_Fin_Registro"] = pd.to_datetime(df["Fecha_Fin_Registro"], errors="coerce")
df["Dias_entre_examen_y_fin"] = (df["Fecha_Fin_Registro"] - df["Fecha_Examen"]).dt.days

# --- 5. Selección de características ---
features_seleccionadas = [
    "Edad_Años", "Dias_entre_examen_y_fin", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

# --- 6. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 7. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RIDGE REGRESSION")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 11. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Ridge Regression\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Lasso Regression_1"""

# @title Entrenar Lasso Regression con categorías de glucosa + MAE
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import Lasso
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Crear columna de días entre examen y fin ---
df["Fecha_Examen"] = pd.to_datetime(df["Fecha_Examen"], errors="coerce")
df["Fecha_Fin_Registro"] = pd.to_datetime(df["Fecha_Fin_Registro"], errors="coerce")
df["Dias_entre_examen_y_fin"] = (df["Fecha_Fin_Registro"] - df["Fecha_Examen"]).dt.days

# --- 4. Selección de features y target ---
features_seleccionadas = [
    "Edad_Años", "Dias_entre_examen_y_fin", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 5. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 6. Pipeline con Lasso Regression ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", Lasso(alpha=0.1, random_state=42))
])

# --- 7. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 8. Entrenar ---
model.fit(X_train, y_train)

# --- 9. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Lasso Regression)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_lasso_regression.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo de Lasso Regression guardado en: {ruta_guardado}")

# @title Cargar modelo Lasso Regression y graficar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_lasso_regression.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Crear columna de días entre examen y fin ---
df["Fecha_Examen"] = pd.to_datetime(df["Fecha_Examen"], errors="coerce")
df["Fecha_Fin_Registro"] = pd.to_datetime(df["Fecha_Fin_Registro"], errors="coerce")
df["Dias_entre_examen_y_fin"] = (df["Fecha_Fin_Registro"] - df["Fecha_Examen"]).dt.days

# --- 5. Selección de características ---
features_seleccionadas = [
    "Edad_Años", "Dias_entre_examen_y_fin", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

# --- 6. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 7. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO LASSO REGRESSION")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 11. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Lasso Regression\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Lasso Regression_2"""

# @title Entrenar Lasso Regression (sin Dias_entre_examen_y_fin)
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import Lasso
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features (sin Dias_entre_examen_y_fin) ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Lasso Regression ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", Lasso(alpha=0.1, random_state=42))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO LASSO REGRESSION (sin Dias_entre_examen_y_fin)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_lasso_regression_2.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo de Lasso Regression guardado en: {ruta_guardado}")

# @title Cargar modelo Lasso y graficar predicciones
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_lasso_regression_2.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de features ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

# --- 5. Limpieza de datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División 70% / 30% ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 8. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO LASSO REGRESSION (sin Dias_entre_examen_y_fin)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Preparar datos para gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 10. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Lasso Regression (sin Dias_entre_examen_y_fin)\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Gradient Boosting_1"""

# @title Entrenar Gradient Boosting con columnas categóricas y de texto
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Selección de features y target ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion","Nombre_Completo","identificacion",
    "nombres","apellidos"
]
target = "Resultado"

# --- 3. Limpiar datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Gradient Boosting ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", GradientBoostingRegressor(
        n_estimators=200,
        learning_rate=0.1,
        max_depth=5,
        random_state=42
    ))
])

# --- 6. División de datos ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("COMPARACIÓN DE MÉTRICAS: TRAIN vs TEST (Gradient Boosting)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_gradient_boosting.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo Gradient Boosting guardado en: {ruta_guardado}")

# @title Gráfica de predicciones vs valores reales (Gradient Boosting)
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import joblib
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error

# --- 1. Cargar datos y modelo ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_gradient_boosting.joblib"

df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 2. Features utilizadas ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion","Nombre_Completo","identificacion",
    "nombres","apellidos"
]
target = "Resultado"

# --- 3. Limpiar datos ---
df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. División train/test ---
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 5. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# --- 6. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = (mean_squared_error(y_train, y_pred_train))**0.5
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = (mean_squared_error(y_test, y_pred_test))**0.5
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO GRADIENT BOOSTING")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f}")
print("="*50)

# --- 7. Preparar DataFrame para la gráfica ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

# --- 8. Gráfica comparativa ---
min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Gradient Boosting\nR² prueba={r2_test:.3f} | RMSE prueba={rmse_test:.2f} | MAE prueba={mae_test:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Gradient Boosting_2"""

# @title Entrenar modelo Gradient Boosting Regression
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con Gradient Boosting ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", GradientBoostingRegressor(
        n_estimators=200,
        learning_rate=0.1,
        max_depth=5,
        random_state=42
    ))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Evaluación ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = (mean_squared_error(y_train, y_pred_train))**0.5
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = (mean_squared_error(y_test, y_pred_test))**0.5
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO GRADIENT BOOSTING")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} mg/dL | MAE={mae_tr:.2f} mg/dL")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} mg/dL | MAE={mae_te:.2f} mg/dL")
print("="*50)

# --- 9. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_gradient_boosting_2.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo Gradient Boosting guardado en: {ruta_guardado}")

# @title
# --- 1. Importaciones ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 2. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_gradient_boosting_2.joblib"

# --- 3. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 4. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 5. Selección de features (sin 'Dias_entre_examen_y_fin') ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División de datos ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 8. Métricas ---
r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO GRADIENT BOOSTING")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} | MAE={mae_tr:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} | MAE={mae_te:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Gradient Boosting \nR² prueba={r2_te:.3f} | RMSE prueba={rmse_te:.2f} | MAE prueba={mae_te:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Support Vector Machine_1"""

# @title Entrenar Support Vector Machine con categorías de glucosa
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import numpy as np
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa",

]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", StandardScaler(), numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con SVM ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", SVR(kernel='rbf', C=100, gamma='scale'))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO SVM")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_svm.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo SVM guardado en: {ruta_guardado}")

# @title
# --- 1. Importaciones ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 2. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_svm.joblib"  # Cambiar por tu SVM

# --- 3. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 4. Crear categoría de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 5. Selección de features ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División de datos ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 8. Métricas ---
r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO SVM")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} | MAE={mae_tr:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} | MAE={mae_te:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"SVM \nR² prueba={r2_te:.3f} | RMSE prueba={rmse_te:.2f} | MAE prueba={mae_te:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Support Vector Machine_2"""

# @title Entrenar Support Vector Machine con categorías de glucosa
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import numpy as np
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target ---
features_seleccionadas = [
     "Categoria_Glucosa", "Identificacion", "Nombre_Completo",
    "identificacion", "nombres", "apellidos"

]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", StandardScaler(), numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con SVM ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", SVR(kernel='rbf', C=100, gamma='scale'))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO SVM")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_svm_2.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo SVM guardado en: {ruta_guardado}")

# @title
# --- 1. Importaciones ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 2. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_svm_2.joblib"

# --- 3. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 4. Crear categoría de glucosa (si no existe) ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 5. Selección de features (solo categóricas) ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion", "Nombre_Completo",
    "identificacion", "nombres", "apellidos"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 6. División de datos ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 8. Métricas ---
r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO GRADIENT BOOSTING (CATEGÓRICAS)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} | MAE={mae_tr:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} | MAE={mae_te:.2f} | n={len(y_test)}")
print("="*50)

# --- 9. Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Gradient Boosting (Categóricas) \nR² prueba={r2_te:.3f} | RMSE prueba={rmse_te:.2f} | MAE prueba={mae_te:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Support Red Neuronal (MLP)"""

# @title Entrenar Red Neuronal (MLP) con categorías de glucosa
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.neural_network import MLPRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import numpy as np
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion", "Nombre_Completo",
    "identificacion", "nombres", "apellidos"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", StandardScaler(), numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con MLPRegressor ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", MLPRegressor(hidden_layer_sizes=(100, 50),
                               activation='relu',
                               solver='adam',
                               max_iter=1000,
                               random_state=42))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RED NEURONAL (MLP)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_mlp_2.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo Red Neuronal (MLP) guardado en: {ruta_guardado}")

# @title Gráfica comparativa Red Neuronal (MLP)
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import joblib
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_mlp_2.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de features y target ---
features_seleccionadas = [
    "Categoria_Glucosa", "Identificacion", "Nombre_Completo",
    "identificacion", "nombres", "apellidos"
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 5. División de datos ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 6. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 7. Métricas ---
r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RED NEURONAL (MLP)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} | MAE={mae_tr:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} | MAE={mae_te:.2f} | n={len(y_test)}")
print("="*50)

# --- 8. Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Red Neuronal (MLP) \nR² prueba={r2_te:.3f} | RMSE prueba={rmse_te:.2f} | MAE prueba={mae_te:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# Modelo Entrenado ML Support Red Neuronal (MLP)_2"""

# @title Entrenar Red Neuronal (MLP) con categorías de glucosa
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.neural_network import MLPRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import numpy as np
import joblib

# --- 1. Cargar datos ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
df = pd.read_csv(ruta_csv)

# --- 2. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 3. Selección de features y target ---
features_seleccionadas = [
     "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa",
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 4. Preprocesamiento ---
numeric_cols = X.select_dtypes(include=["int64", "float64"]).columns
categorical_cols = X.select_dtypes(exclude=["int64", "float64"]).columns

preprocessor = ColumnTransformer(
    transformers=[
        ("num", StandardScaler(), numeric_cols),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols)
    ]
)

# --- 5. Pipeline con MLPRegressor ---
model = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("regressor", MLPRegressor(hidden_layer_sizes=(100, 50),
                               activation='relu',
                               solver='adam',
                               max_iter=1000,
                               random_state=42))
])

# --- 6. División de datos (70% train / 30% test) ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 7. Entrenar ---
model.fit(X_train, y_train)

# --- 8. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 9. Métricas ---
r2_train = r2_score(y_train, y_pred_train)
rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_train = mean_absolute_error(y_train, y_pred_train)

r2_test = r2_score(y_test, y_pred_test)
rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_test = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RED NEURONAL (MLP)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_train:.3f} | RMSE={rmse_train:.2f} | MAE={mae_train:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_test:.3f} | RMSE={rmse_test:.2f} | MAE={mae_test:.2f} | n={len(y_test)}")
print("="*50)

# --- 10. Guardar modelo ---
ruta_guardado = "/content/drive/MyDrive/ML Glucosa/modelo_mlp.joblib"
joblib.dump(model, ruta_guardado)
print(f"✅ Modelo Red Neuronal (MLP) guardado en: {ruta_guardado}")

# @title Gráfica comparativa Red Neuronal (MLP)
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import joblib
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.model_selection import train_test_split

# --- 1. Rutas ---
ruta_csv = "/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv"
ruta_modelo = "/content/drive/MyDrive/ML Glucosa/modelo_mlp.joblib"

# --- 2. Cargar datos y modelo ---
df = pd.read_csv(ruta_csv)
model = joblib.load(ruta_modelo)

# --- 3. Crear columna de categorías de glucosa ---
def clasificar_glucosa(valor):
    if valor <= 100:
        return "Normal"
    elif valor <= 125:
        return "Prediabetes"
    else:
        return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de features y target ---
features_seleccionadas = [
    "Edad_Años", "peso", "talla",
    "imc", "tas", "tad", "Categoria_Glucosa",
]
target = "Resultado"

df_limpio = df.dropna(subset=features_seleccionadas + [target]).copy()
X = df_limpio[features_seleccionadas]
y = df_limpio[target]

# --- 5. División de datos ---
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# --- 6. Predicciones ---
y_pred_train = model.predict(X_train)
y_pred_test  = model.predict(X_test)

# --- 7. Métricas ---
r2_tr = r2_score(y_train, y_pred_train)
rmse_tr = np.sqrt(mean_squared_error(y_train, y_pred_train))
mae_tr = mean_absolute_error(y_train, y_pred_train)

r2_te = r2_score(y_test, y_pred_test)
rmse_te = np.sqrt(mean_squared_error(y_test, y_pred_test))
mae_te = mean_absolute_error(y_test, y_pred_test)

print("="*50)
print("EVALUACIÓN DEL MODELO RED NEURONAL (MLP)")
print("="*50)
print(f"[ENTRENAMIENTO] R²={r2_tr:.3f} | RMSE={rmse_tr:.2f} | MAE={mae_tr:.2f} | n={len(y_train)}")
print(f"[PRUEBA       ] R²={r2_te:.3f} | RMSE={rmse_te:.2f} | MAE={mae_te:.2f} | n={len(y_test)}")
print("="*50)

# --- 8. Gráfica comparativa ---
df_plot_train = pd.DataFrame({"y_true": y_train, "y_pred": y_pred_train, "split": "Entrenamiento (70%)"})
df_plot_test  = pd.DataFrame({"y_true": y_test, "y_pred": y_pred_test, "split": "Prueba (30%)"})
df_plot = pd.concat([df_plot_train, df_plot_test], axis=0)

min_val = min(df_plot["y_true"].min(), df_plot["y_pred"].min())
max_val = max(df_plot["y_true"].max(), df_plot["y_pred"].max())
xs = np.linspace(min_val, max_val, 100)

plt.style.use('seaborn-v0_8-whitegrid')
plt.figure(figsize=(8, 8))
sns.scatterplot(data=df_plot, x="y_true", y="y_pred", hue="split", style="split", alpha=0.7)
plt.plot(xs, xs, '--', color='black', label="Predicción Perfecta (y = x)")
plt.title(f"Red Neuronal (MLP) \nR² prueba={r2_te:.3f} | RMSE prueba={rmse_te:.2f} | MAE prueba={mae_te:.2f}")
plt.xlabel("Valores Reales de Glucosa")
plt.ylabel("Predicciones del Modelo")
plt.legend()
plt.show()

"""# comparación Modelos entrenados"""

# @title
import joblib
import pandas as pd
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import numpy as np
import glob
import os

# --- 1. Cargar modelos entrenados ---
ruta_modelos = '/content/drive/MyDrive/ML Glucosa/*.joblib'
archivos_modelos = glob.glob(ruta_modelos)
print(f"✅ Se encontraron {len(archivos_modelos)} modelos entrenados.")

# --- 2. Cargar dataset ---
df = pd.read_csv('/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv')

# --- 3. Crear columna Categoria_Glucosa ---
def clasificar_glucosa(valor):
    if valor < 100: return "Normal"
    elif valor < 126: return "Prediabetes"
    else: return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de features y target ---
features_seleccionadas = ["Edad_Años", "peso", "talla", "imc", "tas", "tad", "Categoria_Glucosa"]
target = "Resultado"

# --- 5. Crear columnas faltantes ---
for col in features_seleccionadas:
    if col not in df.columns:
        df[col] = 0

X = df[features_seleccionadas].copy().fillna(0)
y = df[target]

# --- 6. Evaluar modelos solo en entrenamiento ---
resultados = []
modelos_evaluados = 0

for archivo in archivos_modelos:
    nombre_modelo = os.path.basename(archivo).replace('.joblib','')
    try:
        modelo = joblib.load(archivo)
        try:
            y_pred = modelo.predict(X)
        except:
            cols_modelo = getattr(modelo, "feature_names_in_", X.columns)
            cols_validas = [c for c in features_seleccionadas if c in cols_modelo]
            if len(cols_validas) == 0:
                continue
            y_pred = modelo.predict(X[cols_validas])

        r2_train = r2_score(y, y_pred)
        rmse_train = np.sqrt(mean_squared_error(y, y_pred))
        mae_train = mean_absolute_error(y, y_pred)

        if r2_train >= 0.9: interpretacion = "Excelente"
        elif r2_train >= 0.75: interpretacion = "Buen ajuste"
        elif r2_train >= 0.5: interpretacion = "Moderado"
        else: interpretacion = "Bajo rendimiento"

        resultados.append([nombre_modelo, r2_train, rmse_train, mae_train, interpretacion])
        modelos_evaluados += 1

    except:
        continue

# --- 7. Crear DataFrame de resultados ---
df_resultados = pd.DataFrame(resultados, columns=["Modelo","R² Score","RMSE (mg/dL)","MAE (mg/dL)","Interpretación"])
df_resultados = df_resultados.sort_values(by="R² Score", ascending=False).reset_index(drop=True)

if df_resultados.empty:
    print("⚠️ Ningún modelo pudo evaluarse en entrenamiento.")
else:
    print(f"✅ Modelos evaluados en entrenamiento: {modelos_evaluados}/{len(archivos_modelos)}")

    # --- 8. Graficas lado a lado ---
    fig, axes = plt.subplots(1, 2, figsize=(14,5))
    colores_r2 = "#00bfae"
    colores_rmse = "#ff7043"

    # Gráfico R²
    axes[0].bar(df_resultados["Modelo"], df_resultados["R² Score"], color=colores_r2, edgecolor="black")
    axes[0].set_title("Comparación de R² Score")
    axes[0].set_ylabel("R² Score")
    axes[0].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[0].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["R² Score"]):
        axes[0].text(i, v + 0.01, f"{v:.2f}", ha='center', va='bottom', fontsize=9)

    # Gráfico RMSE
    axes[1].bar(df_resultados["Modelo"], df_resultados["RMSE (mg/dL)"], color=colores_rmse, edgecolor="black")
    axes[1].set_title("Comparación de RMSE (mg/dL)")
    axes[1].set_ylabel("RMSE (mg/dL)")
    axes[1].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[1].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["RMSE (mg/dL)"]):
        axes[1].text(i, v + 0.5, f"{v:.1f}", ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    plt.show()

    # --- 9. Mostrar tabla debajo ---
    print("\n📊 Resultados comparativos de rendimiento de los modelos en entrenamiento:\n")
    display(df_resultados)

# @title Evaluación de modelos entrenados sobre datos de entrenamiento (solo 7 modelos)
import joblib
import pandas as pd
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import numpy as np
import glob
import os
from sklearn.model_selection import train_test_split

# --- 1. Cargar modelos entrenados ---
ruta_modelos = '/content/drive/MyDrive/ML Glucosa/*.joblib'
archivos_modelos = glob.glob(ruta_modelos)

# --- 2. Cargar dataset ---
df = pd.read_csv('/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv')

# --- 3. Crear columna Categoria_Glucosa ---
def clasificar_glucosa(valor):
    if valor < 100: return "Normal"
    elif valor < 126: return "Prediabetes"
    else: return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de features y target ---
features_entrenamiento = ["Edad_Años", "peso", "talla", "imc", "tas", "tad", "Categoria_Glucosa"]
target = "Resultado"

# --- 5. Limpiar datos y crear columnas faltantes ---
for col in features_entrenamiento:
    if col not in df.columns:
        df[col] = 0

df = df.dropna(subset=features_entrenamiento + [target])
X = df[features_entrenamiento].copy()
y = df[target]

# --- 6. Dividir en entrenamiento 70% y prueba 30% ---
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# --- 7. Evaluar modelos solo en entrenamiento ---
resultados = []
modelos_evaluados = 0

for archivo in archivos_modelos:
    nombre_modelo = os.path.basename(archivo).replace('.joblib','')
    try:
        modelo = joblib.load(archivo)

        # Seleccionar columnas válidas que el modelo acepte
        if not hasattr(modelo, "feature_names_in_"):
            continue  # saltar modelos sin feature_names_in_
        cols_modelo = modelo.feature_names_in_
        cols_validas = [c for c in features_entrenamiento if c in cols_modelo]
        if len(cols_validas) < len(features_entrenamiento):
            continue  # saltar si no tiene todos los features requeridos

        # Predecir sobre entrenamiento
        y_pred_train = modelo.predict(X_train[cols_validas])

        # Calcular métricas
        r2_train = r2_score(y_train, y_pred_train)
        rmse_train = np.sqrt(mean_squared_error(y_train, y_pred_train))
        mae_train = mean_absolute_error(y_train, y_pred_train)

        # Interpretación
        if r2_train >= 0.9: interpretacion = "Excelente"
        elif r2_train >= 0.75: interpretacion = "Buen ajuste"
        elif r2_train >= 0.5: interpretacion = "Moderado"
        else: interpretacion = "Bajo rendimiento"

        resultados.append([nombre_modelo, r2_train, rmse_train, mae_train, interpretacion])
        modelos_evaluados += 1

    except:
        continue

# --- 8. Crear DataFrame de resultados ---
df_resultados = pd.DataFrame(resultados, columns=["Modelo","R² Score","RMSE (mg/dL)","MAE (mg/dL)","Interpretación"])
df_resultados = df_resultados.sort_values(by="R² Score", ascending=False).reset_index(drop=True)

if df_resultados.empty:
    print("⚠️ Ningún modelo pudo evaluarse en entrenamiento.")
else:
    print(f"✅ Modelos evaluados en entrenamiento: {modelos_evaluados}/{len(archivos_modelos)}")

    # --- 9. Graficas lado a lado ---
    fig, axes = plt.subplots(1, 2, figsize=(14,5))
    colores_r2 = "#00bfae"
    colores_rmse = "#ff7043"

    # R²
    axes[0].bar(df_resultados["Modelo"], df_resultados["R² Score"], color=colores_r2, edgecolor="black")
    axes[0].set_title("Comparación de R² Score (entrenamiento)")
    axes[0].set_ylabel("R² Score")
    axes[0].set_xticks(range(len(df_resultados["Modelo"])))
    axes[0].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[0].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["R² Score"]):
        axes[0].text(i, v + 0.01, f"{v:.2f}", ha='center', va='bottom', fontsize=9)

    # RMSE
    axes[1].bar(df_resultados["Modelo"], df_resultados["RMSE (mg/dL)"], color=colores_rmse, edgecolor="black")
    axes[1].set_title("Comparación de RMSE (mg/dL) (entrenamiento)")
    axes[1].set_ylabel("RMSE (mg/dL)")
    axes[1].set_xticks(range(len(df_resultados["Modelo"])))
    axes[1].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[1].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["RMSE (mg/dL)"]):
        axes[1].text(i, v + 0.5, f"{v:.1f}", ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    plt.show()

    # --- 10. Mostrar tabla ---
    print("\n📊 Resultados comparativos de rendimiento de los modelos sobre entrenamiento:\n")
    display(df_resultados)

# @title Evaluación de modelos entrenados sobre datos de prueba (solo 7 modelos)
import joblib
import pandas as pd
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import numpy as np
import glob
import os
from sklearn.model_selection import train_test_split

# --- 1. Cargar modelos entrenados ---
ruta_modelos = '/content/drive/MyDrive/ML Glucosa/*.joblib'
archivos_modelos = glob.glob(ruta_modelos)

# --- 2. Cargar dataset ---
df = pd.read_csv('/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv')

# --- 3. Crear columna Categoria_Glucosa ---
def clasificar_glucosa(valor):
    if valor < 100: return "Normal"
    elif valor < 126: return "Prediabetes"
    else: return "Diabetes"

df["Categoria_Glucosa"] = df["Resultado"].apply(clasificar_glucosa)

# --- 4. Selección de features y target ---
features_entrenamiento = ["Edad_Años", "peso", "talla", "imc", "tas", "tad", "Categoria_Glucosa"]
target = "Resultado"

# --- 5. Limpiar datos y crear columnas faltantes ---
for col in features_entrenamiento:
    if col not in df.columns:
        df[col] = 0

df = df.dropna(subset=features_entrenamiento + [target])
X = df[features_entrenamiento].copy()
y = df[target]

# --- 6. Dividir en entrenamiento 70% y prueba 30% ---
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# --- 7. Evaluar modelos solo en prueba ---
resultados_test = []
modelos_evaluados = 0

for archivo in archivos_modelos:
    nombre_modelo = os.path.basename(archivo).replace('.joblib','')
    try:
        modelo = joblib.load(archivo)

        # Seleccionar columnas válidas que el modelo acepte
        if not hasattr(modelo, "feature_names_in_"):
            continue  # saltar modelos sin feature_names_in_
        cols_modelo = modelo.feature_names_in_
        cols_validas = [c for c in features_entrenamiento if c in cols_modelo]
        if len(cols_validas) < len(features_entrenamiento):
            continue  # saltar si no tiene todos los features requeridos

        # Predecir sobre prueba
        y_pred_test = modelo.predict(X_test[cols_validas])

        # Calcular métricas
        r2_test = r2_score(y_test, y_pred_test)
        rmse_test = np.sqrt(mean_squared_error(y_test, y_pred_test))
        mae_test = mean_absolute_error(y_test, y_pred_test)

        # Interpretación
        if r2_test >= 0.9: interpretacion = "Excelente"
        elif r2_test >= 0.75: interpretacion = "Buen ajuste"
        elif r2_test >= 0.5: interpretacion = "Moderado"
        else: interpretacion = "Bajo rendimiento"

        resultados_test.append([nombre_modelo, r2_test, rmse_test, mae_test, interpretacion])
        modelos_evaluados += 1

    except:
        continue

# --- 8. Crear DataFrame de resultados ---
df_resultados_test = pd.DataFrame(resultados_test, columns=["Modelo","R² Score","RMSE (mg/dL)","MAE (mg/dL)","Interpretación"])
df_resultados_test = df_resultados_test.sort_values(by="R² Score", ascending=False).reset_index(drop=True)

if df_resultados_test.empty:
    print("⚠️ Ningún modelo pudo evaluarse en prueba.")
else:
    print(f"✅ Modelos evaluados en prueba: {modelos_evaluados}/{len(archivos_modelos)}")

    # --- 9. Graficas lado a lado ---
    fig, axes = plt.subplots(1, 2, figsize=(14,5))
    colores_r2 = "#3f51b5"
    colores_rmse = "#e91e63"

    # R²
    axes[0].bar(df_resultados_test["Modelo"], df_resultados_test["R² Score"], color=colores_r2, edgecolor="black")
    axes[0].set_title("Comparación de R² Score (prueba)")
    axes[0].set_ylabel("R² Score")
    axes[0].set_xticks(range(len(df_resultados_test["Modelo"])))
    axes[0].set_xticklabels(df_resultados_test["Modelo"], rotation=30, ha="right")
    axes[0].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados_test["R² Score"]):
        axes[0].text(i, v + 0.01, f"{v:.2f}", ha='center', va='bottom', fontsize=9)

    # RMSE
    axes[1].bar(df_resultados_test["Modelo"], df_resultados_test["RMSE (mg/dL)"], color=colores_rmse, edgecolor="black")
    axes[1].set_title("Comparación de RMSE (mg/dL) (prueba)")
    axes[1].set_ylabel("RMSE (mg/dL)")
    axes[1].set_xticks(range(len(df_resultados_test["Modelo"])))
    axes[1].set_xticklabels(df_resultados_test["Modelo"], rotation=30, ha="right")
    axes[1].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados_test["RMSE (mg/dL)"]):
        axes[1].text(i, v + 0.5, f"{v:.1f}", ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    plt.show()

    # --- 10. Mostrar tabla ---
    print("\n📊 Resultados comparativos de rendimiento de los modelos sobre prueba:\n")
    display(df_resultados_test)

# @title
import joblib
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import glob
import os
# --- 1. Cargar modelos entrenados ---
ruta_modelos = '/content/drive/MyDrive/ML Glucosa/*.joblib'
archivos_modelos = glob.glob(ruta_modelos)
print(f"✅ Se encontraron {len(archivos_modelos)} modelos entrenados.")

# --- 2. Features clínicas a evaluar ---
features_clinicas = ["Edad_Años", "peso", "talla", "imc", "tas", "tad", "Categoria_Glucosa"]

# --- 3. Evaluar solo modelos que tengan estas columnas y métricas de entrenamiento ---
resultados = []
modelos_evaluados = 0

for archivo in archivos_modelos:
    nombre_modelo = os.path.basename(archivo).replace('.joblib','')
    try:
        modelo = joblib.load(archivo)

        # Detectar features del modelo
        try:
            cols_modelo = modelo.named_steps['preprocessor'].get_feature_names_out()
        except:
            cols_modelo = getattr(modelo, "feature_names_in_", [])

        # Solo incluir si tiene todos los features clínicos
        if all(f in cols_modelo for f in features_clinicas):
            # Tomar métricas de entrenamiento
            r2_train = getattr(modelo, "r2_train_", None)
            rmse_train = getattr(modelo, "rmse_train_", None)
            mae_train = getattr(modelo, "mae_train_", None)

            if r2_train is not None and rmse_train is not None and mae_train is not None:
                # Interpretación simple
                if r2_train >= 0.9:
                    interpretacion = "Excelente"
                elif r2_train >= 0.75:
                    interpretacion = "Buen ajuste"
                elif r2_train >= 0.5:
                    interpretacion = "Moderado"
                else:
                    interpretacion = "Bajo rendimiento"

                resultados.append([nombre_modelo, r2_train, rmse_train, mae_train, interpretacion])
                modelos_evaluados += 1

    except Exception as e:
        print(f"⚠️ Error cargando {nombre_modelo}: {e}")

# --- 4. Crear DataFrame de resultados ---
df_resultados = pd.DataFrame(resultados, columns=["Modelo","R² Score","RMSE (mg/dL)","MAE (mg/dL)","Interpretación"])
df_resultados = df_resultados.sort_values(by="R² Score", ascending=False).reset_index(drop=True)

if df_resultados.empty:
    print("⚠️ Ningún modelo tiene las métricas de entrenamiento y features requeridos para mostrar.")
else:
    print(f"✅ Modelos evaluados: {modelos_evaluados}/{len(archivos_modelos)}")

    # --- 5. Graficas lado a lado ---
    fig, axes = plt.subplots(1, 2, figsize=(12,5))
    colores_r2 = "#00bfae"
    colores_rmse = "#ff7043"

    # Gráfico R²
    axes[0].bar(df_resultados["Modelo"], df_resultados["R² Score"], color=colores_r2, edgecolor="black")
    axes[0].set_title("R² Score (Entrenamiento)")
    axes[0].set_ylabel("R²")
    axes[0].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[0].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["R² Score"]):
        axes[0].text(i, v + 0.01, f"{v:.2f}", ha='center', va='bottom', fontsize=9)

    # Gráfico RMSE
    axes[1].bar(df_resultados["Modelo"], df_resultados["RMSE (mg/dL)"], color=colores_rmse, edgecolor="black")
    axes[1].set_title("RMSE (mg/dL) Entrenamiento")
    axes[1].set_ylabel("RMSE")
    axes[1].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[1].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["RMSE (mg/dL)"]):
        axes[1].text(i, v + 0.5, f"{v:.1f}", ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    plt.show()

    # --- 6. Mostrar tabla debajo ---
    print("\n📊 Resultados comparativos de rendimiento de los modelos en entrenamiento (features clínicas):\n")
    display(df_resultados)

# @title
import joblib
import pandas as pd
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import numpy as np
import glob
import os

# --- 1. Cargar modelos entrenados ---
ruta_modelos = '/content/drive/MyDrive/ML Glucosa/*.joblib'
archivos_modelos = glob.glob(ruta_modelos)
print(f"✅ Se encontraron {len(archivos_modelos)} modelos entrenados.")

# --- 2. Cargar dataset ---
df = pd.read_csv('/content/drive/MyDrive/ML Glucosa/Glucosa_Unique_Completo.csv')

# --- 3. Selección de features y target ---
features_id = ["Categoria_Glucosa", "Identificacion", "Nombre_Completo",
               "identificacion", "nombres", "apellidos"]
target = "Resultado"

# --- 4. Crear columnas faltantes ---
for col in features_id:
    if col not in df.columns:
        df[col] = 0

X = df[features_id].copy().fillna(0)
y = df[target]

# --- 5. Evaluar modelos solo en entrenamiento ---
resultados = []
modelos_evaluados = 0

for archivo in archivos_modelos:
    nombre_modelo = os.path.basename(archivo).replace('.joblib','')
    try:
        modelo = joblib.load(archivo)
        try:
            y_pred = modelo.predict(X)
        except:
            cols_modelo = getattr(modelo, "feature_names_in_", X.columns)
            cols_validas = [c for c in features_id if c in cols_modelo]
            if len(cols_validas) == 0:
                continue
            y_pred = modelo.predict(X[cols_validas])

        r2_train = r2_score(y, y_pred)
        rmse_train = np.sqrt(mean_squared_error(y, y_pred))
        mae_train = mean_absolute_error(y, y_pred)

        if r2_train >= 0.9: interpretacion = "Excelente"
        elif r2_train >= 0.75: interpretacion = "Buen ajuste"
        elif r2_train >= 0.5: interpretacion = "Moderado"
        else: interpretacion = "Bajo rendimiento"

        resultados.append([nombre_modelo, r2_train, rmse_train, mae_train, interpretacion])
        modelos_evaluados += 1

    except:
        continue

# --- 6. Crear DataFrame de resultados ---
df_resultados = pd.DataFrame(resultados, columns=["Modelo","R² Score","RMSE (mg/dL)","MAE (mg/dL)","Interpretación"])
df_resultados = df_resultados.sort_values(by="R² Score", ascending=False).reset_index(drop=True)

if df_resultados.empty:
    print("⚠️ Ningún modelo pudo evaluarse en entrenamiento con las columnas de identificación.")
else:
    print(f"✅ Modelos evaluados en entrenamiento: {modelos_evaluados}/{len(archivos_modelos)}")

    # --- 7. Graficas lado a lado ---
    fig, axes = plt.subplots(1, 2, figsize=(14,5))
    colores_r2 = "#00bfae"
    colores_rmse = "#ff7043"

    # Gráfico R²
    axes[0].bar(df_resultados["Modelo"], df_resultados["R² Score"], color=colores_r2, edgecolor="black")
    axes[0].set_title("Comparación de R² Score")
    axes[0].set_ylabel("R² Score")
    axes[0].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[0].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["R² Score"]):
        axes[0].text(i, v + 0.01, f"{v:.2f}", ha='center', va='bottom', fontsize=9)

    # Gráfico RMSE
    axes[1].bar(df_resultados["Modelo"], df_resultados["RMSE (mg/dL)"], color=colores_rmse, edgecolor="black")
    axes[1].set_title("Comparación de RMSE (mg/dL)")
    axes[1].set_ylabel("RMSE (mg/dL)")
    axes[1].set_xticklabels(df_resultados["Modelo"], rotation=30, ha="right")
    axes[1].grid(axis="y", linestyle="--", alpha=0.7)
    for i, v in enumerate(df_resultados["RMSE (mg/dL)"]):
        axes[1].text(i, v + 0.5, f"{v:.1f}", ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    plt.show()

    # --- 8. Mostrar tabla debajo ---
    print("\n📊 Resultados comparativos de rendimiento de los modelos (Columnas de Identificación):\n")
    display(df_resultados)

# @title Predicción comparativa con los 7 modelos entrenados (solo sus features)
import os
import joblib
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Ruta donde están tus modelos
ruta_modelos = "/content/drive/MyDrive/ML Glucosa/"

# Lista de los 7 modelos válidos (ajusta los nombres exactos si difieren)
modelos_validos = [
    "modelo_rf_features_seleccionadas.joblib",
    "modelo_gradient_boosting_2.joblib",
    "modelo_mlp.joblib",
    "modelo_lasso_regression_2.joblib",
    "modelo_regresion_lineal.joblib",
    "modelo_svm.joblib",
    "modelo_svm_regression.joblib"
]

# ==============================
# ENTRADA DE DATOS
# ==============================
def hacer_pregunta(pregunta, tipo):
    while True:
        respuesta = input(pregunta).strip()
        if tipo == 'numerico':
            try:
                return float(respuesta)
            except ValueError:
                print("Por favor ingrese un número válido.")
        elif tipo == 'categorico':
            return respuesta

print("\n" + "="*50)
print("🔍 PREDICCIÓN DE GLUCOSA - Comparación entre Modelos Entrenados")
print("="*50)

# Solicitar datos reales
datos_usuario_dict = {}
datos_usuario_dict["Edad_Años"] = hacer_pregunta("1️⃣ Edad en años: ", "numerico")
datos_usuario_dict["peso"] = hacer_pregunta("2️⃣ Peso (kg): ", "numerico")
datos_usuario_dict["talla"] = hacer_pregunta("3️⃣ Talla (m): ", "numerico")
datos_usuario_dict["imc"] = datos_usuario_dict["peso"] / (datos_usuario_dict["talla"] ** 2)
datos_usuario_dict["tas"] = hacer_pregunta("4️⃣ Presión arterial sistólica (TAS): ", "numerico")
datos_usuario_dict["tad"] = hacer_pregunta("5️⃣ Presión arterial diastólica (TAD): ", "numerico")
datos_usuario_dict["Categoria_Glucosa"] = hacer_pregunta("6️⃣ Categoría de glucosa (Ej: Normal, Alta, Muy Alta): ", "categorico")

# Crear DataFrame base con las features más comunes
df_base = pd.DataFrame([datos_usuario_dict])

# ==============================
# EVALUACIÓN DE LOS MODELOS
# ==============================
resultados = []

for modelo_nombre in modelos_validos:
    ruta = os.path.join(ruta_modelos, modelo_nombre)
    if not os.path.exists(ruta):
        continue

    try:
        modelo = joblib.load(ruta)

        # Detectar qué columnas necesita el modelo
        if hasattr(modelo, "feature_names_in_"):
            columnas = modelo.feature_names_in_
            X_input = df_base.reindex(columns=columnas, fill_value=np.nan)
        else:
            X_input = df_base.copy()

        # Realizar predicción
        pred = modelo.predict(X_input)[0]
        resultados.append({"Modelo": modelo_nombre.replace(".joblib", ""), "Predicción (mg/dL)": round(pred, 2)})

    except Exception as e:
        print(f"⚠️ Error evaluando {modelo_nombre}: {e}")

# ==============================
# RESULTADOS
# ==============================
if len(resultados) > 0:
    df_resultados = pd.DataFrame(resultados).sort_values(by="Predicción (mg/dL)")
    print("\n📊 RESULTADOS DE PREDICCIÓN ENTRE LOS 7 MODELOS:\n")
    print(df_resultados.to_string(index=False))

    # Gráfico comparativo
    plt.figure(figsize=(10, 5))
    bars = plt.bar(df_resultados["Modelo"], df_resultados["Predicción (mg/dL)"])
    plt.xticks(rotation=30, ha='right')
    plt.ylabel("Glucosa Predicha (mg/dL)")
    plt.title("Comparación de Predicciones entre Modelos Entrenados")
    plt.tight_layout()

    # Etiquetas en las barras
    for bar in bars:
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5, f"{bar.get_height():.1f}",
                 ha='center', va='bottom', fontsize=9)

    plt.show()
else:
    print("⚠️ Ninguno de los modelos pudo realizar la predicción.")

# @title Predicción comparativa con los 7 modelos entrenados (sin preguntar Categoria_Glucosa)
import os
import joblib
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Ruta donde están tus modelos
ruta_modelos = "/content/drive/MyDrive/ML Glucosa/"

# Lista de los 7 modelos válidos
modelos_validos = [
    "modelo_rf_features_seleccionadas.joblib",
    "modelo_gradient_boosting_2.joblib",
    "modelo_mlp.joblib",
    "modelo_lasso_regression_2.joblib",
    "modelo_regresion_lineal.joblib",
    "modelo_svm.joblib",
    "modelo_svm_regression.joblib"
]

# ==============================
# ENTRADA DE DATOS
# ==============================
def hacer_pregunta(pregunta, tipo):
    while True:
        respuesta = input(pregunta).strip()
        if tipo == 'numerico':
            try:
                return float(respuesta)
            except ValueError:
                print("Por favor ingrese un número válido.")
        elif tipo == 'categorico':
            return respuesta

print("\n" + "="*50)
print("🔍 PREDICCIÓN DE GLUCOSA - Comparación entre Modelos Entrenados")
print("="*50)

# Solicitar datos reales al usuario
datos_usuario_dict = {}
datos_usuario_dict["Edad_Años"] = hacer_pregunta("1️⃣ Edad en años: ", "numerico")
datos_usuario_dict["peso"] = hacer_pregunta("2️⃣ Peso (kg): ", "numerico")
datos_usuario_dict["talla"] = hacer_pregunta("3️⃣ Talla (m): ", "numerico")
datos_usuario_dict["imc"] = datos_usuario_dict["peso"] / (datos_usuario_dict["talla"] ** 2)
datos_usuario_dict["tas"] = hacer_pregunta("4️⃣ Presión arterial sistólica (TAS): ", "numerico")
datos_usuario_dict["tad"] = hacer_pregunta("5️⃣ Presión arterial diastólica (TAD): ", "numerico")

# =================================
# Rellenar Categoria_Glucosa con un valor por defecto
# =================================
datos_usuario_dict["Categoria_Glucosa"] = "desconocida"

# Crear DataFrame base con las features más comunes
df_base = pd.DataFrame([datos_usuario_dict])

# ==============================
# EVALUACIÓN DE LOS MODELOS
# ==============================
resultados = []

for modelo_nombre in modelos_validos:
    ruta = os.path.join(ruta_modelos, modelo_nombre)
    if not os.path.exists(ruta):
        continue

    try:
        modelo = joblib.load(ruta)

        # Detectar qué columnas necesita el modelo
        if hasattr(modelo, "feature_names_in_"):
            columnas = modelo.feature_names_in_
            # Reindexar DataFrame para coincidir con las columnas esperadas
            X_input = df_base.reindex(columns=columnas, fill_value=np.nan)
        else:
            X_input = df_base.copy()

        # Realizar predicción
        pred = modelo.predict(X_input)[0]
        resultados.append({"Modelo": modelo_nombre.replace(".joblib", ""), "Predicción (mg/dL)": round(pred, 2)})

    except Exception as e:
        print(f"⚠️ Error evaluando {modelo_nombre}: {e}")

# ==============================
# RESULTADOS
# ==============================
if len(resultados) > 0:
    df_resultados = pd.DataFrame(resultados).sort_values(by="Predicción (mg/dL)")
    print("\n📊 RESULTADOS DE PREDICCIÓN ENTRE LOS 7 MODELOS:\n")
    print(df_resultados.to_string(index=False))

    # Gráfico comparativo
    plt.figure(figsize=(10, 5))
    bars = plt.bar(df_resultados["Modelo"], df_resultados["Predicción (mg/dL)"])
    plt.xticks(rotation=30, ha='right')
    plt.ylabel("Glucosa Predicha (mg/dL)")
    plt.title("Comparación de Predicciones entre Modelos Entrenados")
    plt.tight_layout()

    # Etiquetas en las barras
    for bar in bars:
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5, f"{bar.get_height():.1f}",
                 ha='center', va='bottom', fontsize=9)

    plt.show()
else:
    print("⚠️ Ninguno de los modelos pudo realizar la predicción.")

# @title Predicción comparativa con los 7 modelos entrenados (solo sus features)
import os
import joblib
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Ruta donde están tus modelos
ruta_modelos = "/content/drive/MyDrive/ML Glucosa/"

# Lista de los 7 modelos válidos
modelos_validos = [
    "modelo_rf_features_seleccionadas.joblib",
    "modelo_gradient_boosting_2.joblib",
    "modelo_mlp.joblib",
    "modelo_lasso_regression_2.joblib",
    "modelo_regresion_lineal.joblib",
    "modelo_svm.joblib",
    "modelo_svm_regression.joblib"
]

# ==============================
# ENTRADA DE DATOS
# ==============================
def hacer_pregunta_numerica(pregunta):
    respuesta = input(pregunta).strip()
    if respuesta == "":
        return np.nan
    try:
        return float(respuesta)
    except ValueError:
        print("Valor inválido, se dejará vacío.")
        return np.nan

print("\n" + "="*50)
print("🔍 PREDICCIÓN DE GLUCOSA - Comparación entre Modelos Entrenados")
print("="*50)

# Solicitar solo los datos esenciales
datos_usuario_dict = {}
datos_usuario_dict["Edad_Años"] = hacer_pregunta_numerica("1️⃣ Edad en años: ")
datos_usuario_dict["peso"] = hacer_pregunta_numerica("2️⃣ Peso (kg): ")
datos_usuario_dict["talla"] = hacer_pregunta_numerica("3️⃣ Talla (m): ")
datos_usuario_dict["imc"] = (
    datos_usuario_dict["peso"] / (datos_usuario_dict["talla"] ** 2)
    if pd.notna(datos_usuario_dict["peso"]) and pd.notna(datos_usuario_dict["talla"])
    else np.nan
)
datos_usuario_dict["tas"] = hacer_pregunta_numerica("4️⃣ Presión arterial sistólica (TAS): ")
datos_usuario_dict["tad"] = hacer_pregunta_numerica("5️⃣ Presión arterial diastólica (TAD): ")

# Mantener Categoria_Glucosa en el DataFrame pero NO preguntar
datos_usuario_dict["Categoria_Glucosa"] = np.nan

# Crear DataFrame base
df_base = pd.DataFrame([datos_usuario_dict])

# ==============================
# EVALUACIÓN DE LOS MODELOS
# ==============================
resultados = []

for modelo_nombre in modelos_validos:
    ruta = os.path.join(ruta_modelos, modelo_nombre)
    if not os.path.exists(ruta):
        continue

    try:
        modelo = joblib.load(ruta)

        # Columnas que espera el modelo
        if hasattr(modelo, "feature_names_in_"):
            columnas = modelo.feature_names_in_
            X_input = df_base.reindex(columns=columnas, fill_value=np.nan)

            # Imputar valores faltantes para que el modelo pueda predecir
            for col in X_input.columns:
                if X_input[col].dtype == object:
                    X_input[col] = X_input[col].fillna("Desconocido")  # categóricas
                else:
                    X_input[col] = X_input[col].fillna(X_input[col].median())  # numéricas
        else:
            X_input = df_base.copy()

        # Realizar predicción
        pred = modelo.predict(X_input)[0]
        resultados.append({"Modelo": modelo_nombre.replace(".joblib", ""), "Predicción (mg/dL)": round(pred, 2)})

    except Exception as e:
        print(f"⚠️ Error evaluando {modelo_nombre}: {e}")

# ==============================
# RESULTADOS
# ==============================
if len(resultados) > 0:
    df_resultados = pd.DataFrame(resultados).sort_values(by="Predicción (mg/dL)")
    print("\n📊 RESULTADOS DE PREDICCIÓN ENTRE LOS 7 MODELOS:\n")
    print(df_resultados.to_string(index=False))

    # Gráfico comparativo
    plt.figure(figsize=(10, 5))
    bars = plt.bar(df_resultados["Modelo"], df_resultados["Predicción (mg/dL)"])
    plt.xticks(rotation=30, ha='right')
    plt.ylabel("Glucosa Predicha (mg/dL)")
    plt.title("Comparación de Predicciones entre Modelos Entrenados")
    plt.tight_layout()

    for bar in bars:
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5,
                 f"{bar.get_height():.1f}", ha='center', va='bottom', fontsize=9)

    plt.show()
else:
    print("⚠️ Ningún modelo pudo realizar la predicción.")